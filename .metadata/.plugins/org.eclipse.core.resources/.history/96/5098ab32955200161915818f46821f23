//============================================================================
// Name        : myFirst.cpp
// Author      : Navid Anari
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <vector>
#include <pthread.h>
#include <unistd.h>
#include <mutex>
#include <condition_variable>
#include <map>
#include <queue>
#include <boost/lexical_cast.hpp>

using namespace std;

struct Frame
{
	size_t size = 4000000;
	void * data = new int(size);
}myFrame;

std::queue<Frame> myQ;

class buffer
{
public:
	struct Frame data[10];
	int rear = 0;
	int front = 0;

	bool isEmpty(){
		return (rear == front) ? true : false;
	};
	bool isFull(){
		return (rear == (front+1)%10) ? true : false;
	};
}myBuffer;

pthread_cond_t cond;
pthread_mutex_t mx;

void * writer(void *)
{
	Frame myFrame;
	for(int i = 0; true; i++)
	{
		pthread_mutex_lock(&mx);

		myQ.push(myFrame);

		pthread_cond_signal(&cond);
		pthread_mutex_unlock(&mx);
	}
	pthread_exit(0);
}

void * reader(void *)
{
	Frame myFrame;
	for(int i = 0; true; i++)
	{
		pthread_mutex_lock(&mx);
		while(myQ.empty())
		{
			cout<< "I am waiting"<<endl;
			pthread_cond_wait(&cond, &mx);
		}
		myFrame = myQ.front();
		myQ.pop();
		pthread_mutex_unlock(&mx);
	}
	pthread_exit(0);
}

int main() {

	pthread_t th2,th1;

	pthread_create(&th2, NULL, writer, NULL);
	pthread_create(&th1, NULL, reader, NULL);

	pthread_join(th2, NULL);
	pthread_join(th1, NULL);

	return 0;
}

