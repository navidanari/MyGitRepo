//============================================================================
// Name        : myFirst.cpp
// Author      : Navid Anari
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <vector>
#include <pthread.h>
#include <unistd.h>
#include <mutex>
#include <condition_variable>
#include <map>
#include <queue>
#include <boost/lexical_cast.hpp>

using namespace std;

int glob = 0;
struct Frame
{
	size_t size = 4000000;
	void * data = new int(size);
}myFrame;

class buffer
{
public:
	struct Frame data[10];
	int rear = 0;
	int front = 0;

	bool isEmpty(){
		return (rear == front) ? true : false;
	};
	bool isFull(){
		return (rear == (front+1)%10) ? true : false;
	};
}myBuffer;

pthread_cond_t cond;
pthread_mutex_t mx;

void * writer(void *)
{
	for(int i = 0; true; i++)
	{
		pthread_mutex_lock(&mx);

		if(!myBuffer.isFull())
		{
			myBuffer.data[++myBuffer.front]= myFrame;
			cout<<"   Writing  "<<endl;
		}

		pthread_cond_signal(&cond);
		pthread_mutex_unlock(&mx);
	}


}

void * reader(void *)
{
	for(int i = 0; true; i++)
	{
		pthread_mutex_lock(&mx);
		while(myBuffer.isEmpty())
		{
			cout<< "I am waiting"<<endl;
			pthread_cond_wait(&cond, &mx);
		}
		if (!myBuffer.isEmpty())
		{
			myFrame = myBuffer.data[myBuffer.rear];
			cout<<"   reading  "<<endl;
		}
		pthread_mutex_unlock(&mx);
	}
	sleep(1);

}

int main() {

	pthread_t th2,th1;

	pthread_create(&th2, NULL, writer, NULL);
	pthread_create(&th1, NULL, reader, NULL);

	pthread_join(th2, NULL);
	pthread_join(th1, NULL);

	cout<<glob;

	return 0;
}

