//============================================================================
// Name        : myFirst.cpp
// Author      : Navid Anari
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <vector>
#include <pthread.h>
#include <unistd.h>
#include <mutex>
#include <condition_variable>
#include <map>
#include <queue>
#include <boost/lexical_cast.hpp>

using namespace std;

struct Frame
{
	size_t size = 4000000;
	void * data = new int(size);
	int id;
}myFrame;

std::queue<Frame> myQ;

pthread_cond_t cond;
pthread_mutex_t mx;

void * writer(void *)
{
	size_t qSize;
	Frame myFrame;
	for(int i = 0; i<5000000; i++)
	{
		pthread_mutex_lock(&mx);
		myFrame.id = i;
		myQ.push(myFrame);
		qSize = myQ.size();
		pthread_cond_signal(&cond);
		pthread_mutex_unlock(&mx);
		if(qSize > 300)
			usleep(5000);
	}
	pthread_exit(0);
}

void * reader(void *)
{
	Frame myFrame;
	for(int i = 0; true; i++)
	{
		pthread_mutex_lock(&mx);
		while(myQ.empty())
		{
			cout<< "I am waiting"<<endl;
			pthread_cond_wait(&cond, &mx);
		}
		myFrame = myQ.front();
		myQ.pop();
		cout<<"size is  "<<myQ.size()<<endl;
		pthread_mutex_unlock(&mx);
		cout<< myFrame.id << endl;
	}
	pthread_exit(0);
}

int main() {

	pthread_t th2,th1;

	pthread_create(&th2, NULL, writer, NULL);
	pthread_create(&th1, NULL, reader, NULL);

	pthread_join(th2, NULL);
	pthread_join(th1, NULL);

	return 0;
}

